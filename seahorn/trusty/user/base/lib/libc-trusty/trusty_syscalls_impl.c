#include "sea_handle_table.h"
#include "trusty_syscalls.h"

#include <uapi/err.h> // trusty errors definitions

#include <seahorn/seahorn.h>

#define ND __declspec(noalias)

handle_t _trusty_port_create(const char *path, uint32_t num_recv_bufs,
                             uint32_t recv_buf_size, uint32_t flags) {
  (void)path;
  (void)num_recv_bufs;
  (void)recv_buf_size;

  bool secure = (flags & IPC_PORT_ALLOW_NS_CONNECT) &&
                !(flags & IPC_PORT_ALLOW_TA_CONNECT);
  return sea_ht_new_port(secure);
}

handle_t _trusty_connect(const char *path, uint32_t flags) {
  return INVALID_IPC_HANDLE;
}

extern uint32_t ND nd_time_low(void);
extern uint16_t ND nd_time_mid(void);
extern uint16_t ND nd_time_hi_n_ver(void);

handle_t _trusty_accept(handle_t port_handle, uuid_t *peer_uuid) {
  (void)port_handle;
  handle_t chan = sea_ht_new_channel(port_handle);
  if (chan != INVALID_IPC_HANDLE) {
    // define peer_uuid to a dummy value
    peer_uuid->time_low = nd_time_low();
    peer_uuid->time_mid = nd_time_mid();
    peer_uuid->time_hi_and_version = nd_time_hi_n_ver();
  }
  return chan;
}

int _trusty_close(handle_t handle) {
  sea_ht_free(handle);
  return NO_ERROR;
}

int _trusty_set_cookie(handle_t handle, void *cookie) {
  sea_ht_set_cookie(handle, cookie);
  return NO_ERROR;
}

handle_t _trusty_handle_set_create(void) { return INVALID_IPC_HANDLE; }

int _trusty_handle_set_ctrl(handle_t handle, uint32_t cmd, struct uevent *evt) {
  return ERR_GENERIC;
}

extern int ND nd_trusty_err(void);

extern uint32_t nd_trusty_event(void);

int _trusty_wait(handle_t handle, struct uevent *event,
                 uint32_t timeout_msecs) {
  int err = nd_trusty_err();
  if (err < NO_ERROR)
    return err;

  event->handle = handle;
  event->cookie = sea_ht_get_cookie(handle);
  event->event = nd_trusty_event();

  return NO_ERROR;
}

int _trusty_wait_any(uevent_t *ev, uint32_t timeout_msecs) {
  int err = nd_trusty_err();
  if (err < NO_ERROR)
    return err;


  handle_t h = sea_ht_choose_active_handle();
  ev->handle = h;
  ev->cookie = sea_ht_get_cookie(h);
  ev->event = nd_trusty_event();
  return NO_ERROR;
}

extern uint32_t ND nd_msg_id(void);
extern size_t ND nd_msg_len(void);

#define MAX_MSG_LENGTH 4096

int _trusty_get_msg(handle_t handle, struct ipc_msg_info *msg_info) {
  int err = nd_trusty_err();
  if (err < NO_ERROR)
    return err;

  // TODO: messages should be generated by wait
  // TODO: trusty_get_msg should only return the current message for the given handle

  size_t msg_len = nd_msg_len();
  assume(msg_len > 0);
  assume(msg_len <= MAX_MSG_LENGTH);

  uint32_t msg_id = nd_msg_id();

  msg_info->len = msg_len;
  msg_info->id = msg_id;
  return NO_ERROR;
}

ssize_t _trusty_read_msg(handle_t handle, uint32_t msg_id, uint32_t offset,
                         struct ipc_msg *msg) {
  return 0;
}

int _trusty_put_msg(handle_t handle, uint32_t msg_id) {
  return ERR_GENERIC;
}
ssize_t _trusty_send_msg(handle_t handle, struct ipc_msg *msg) {
  return 0;
}
